{"ast":null,"code":"import _classCallCheck from \"/home/humza/Documents/afterflea/projects/drive-download-20230421T195214Z-001/script/OpenAI-Template.1.3-update-auth-signups (1)/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/humza/Documents/afterflea/projects/drive-download-20230421T195214Z-001/script/OpenAI-Template.1.3-update-auth-signups (1)/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nexport var SelectionText = /*#__PURE__*/function () {\n  function SelectionText(elm) {\n    _classCallCheck(this, SelectionText);\n    this.elm = void 0;\n    this.start = void 0;\n    this.end = void 0;\n    this.value = void 0;\n    var selectionStart = elm.selectionStart,\n      selectionEnd = elm.selectionEnd;\n    this.elm = elm;\n    this.start = selectionStart;\n    this.end = selectionEnd;\n    this.value = this.elm.value;\n  }\n  _createClass(SelectionText, [{\n    key: \"position\",\n    value: function position(start, end) {\n      var _this$elm = this.elm,\n        selectionStart = _this$elm.selectionStart,\n        selectionEnd = _this$elm.selectionEnd;\n      this.start = typeof start === 'number' && !isNaN(start) ? start : selectionStart;\n      this.end = typeof end === 'number' && !isNaN(end) ? end : selectionEnd;\n      this.elm.selectionStart = this.start;\n      this.elm.selectionEnd = this.end;\n      return this;\n    }\n  }, {\n    key: \"insertText\",\n    value: function insertText(text) {\n      // Most of the used APIs only work with the field selected\n      this.elm.focus();\n      this.elm.setRangeText(text);\n      this.value = this.elm.value;\n      this.position();\n      return this;\n    }\n  }, {\n    key: \"getSelectedValue\",\n    value: function getSelectedValue(start, end) {\n      var _this$elm2 = this.elm,\n        selectionStart = _this$elm2.selectionStart,\n        selectionEnd = _this$elm2.selectionEnd;\n      return this.value.slice(typeof start === 'number' && !isNaN(start) ? start : selectionStart, typeof end === 'number' && !isNaN(end) ? start : selectionEnd);\n    }\n  }, {\n    key: \"getLineStartNumber\",\n    value: function getLineStartNumber() {\n      var start = this.start;\n      while (start > 0) {\n        start--;\n        if (this.value.charAt(start) === '\\n') {\n          start++;\n          break;\n        }\n      }\n      return start;\n    }\n    /** Indent on new lines */\n  }, {\n    key: \"getIndentText\",\n    value: function getIndentText() {\n      var start = this.getLineStartNumber();\n      var str = this.getSelectedValue(start);\n      var indent = '';\n      str.replace(/(^(\\s)+)/, function (str, old) {\n        return indent = old;\n      });\n      return indent;\n    }\n  }, {\n    key: \"lineStarInstert\",\n    value: function lineStarInstert(text) {\n      if (text) {\n        var oldStart = this.start;\n        var start = this.getLineStartNumber();\n        var str = this.getSelectedValue(start);\n        this.position(start, this.end).insertText(str.split('\\n').map(function (txt) {\n          return text + txt;\n        }).join('\\n')).position(oldStart + text.length, this.end);\n      }\n      return this;\n    }\n  }, {\n    key: \"lineStarRemove\",\n    value: function lineStarRemove(text) {\n      if (text) {\n        var oldStart = this.start;\n        var start = this.getLineStartNumber();\n        var str = this.getSelectedValue(start);\n        var reg = new RegExp(\"^\" + text, 'g');\n        var newStart = oldStart - text.length;\n        if (!reg.test(str)) {\n          newStart = oldStart;\n        }\n        this.position(start, this.end).insertText(str.split('\\n').map(function (txt) {\n          return txt.replace(reg, '');\n        }).join('\\n')).position(newStart, this.end);\n      }\n    }\n    /** Notify any possible listeners of the change */\n  }, {\n    key: \"notifyChange\",\n    value: function notifyChange() {\n      var event = new Event('input', {\n        bubbles: true,\n        cancelable: false\n      });\n      this.elm.dispatchEvent(event);\n    }\n  }]);\n  return SelectionText;\n}();","map":{"version":3,"sources":["../src/SelectionText.ts"],"names":["SelectionText","elm","start","end","value","constructor","selectionStart","selectionEnd","position","isNaN","insertText","text","focus","setRangeText","getSelectedValue","slice","getLineStartNumber","charAt","getIndentText","str","indent","replace","old","lineStarInstert","oldStart","split","map","txt","join","length","lineStarRemove","reg","RegExp","newStart","test","notifyChange","event","Event","bubbles","cancelable","dispatchEvent"],"mappings":"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","sourcesContent":["export class SelectionText {\n  elm: HTMLTextAreaElement;\n  start: number;\n  end: number;\n  value: string;\n  constructor(elm: HTMLTextAreaElement) {\n    const { selectionStart, selectionEnd } = elm;\n    this.elm = elm;\n    this.start = selectionStart;\n    this.end = selectionEnd;\n    this.value = this.elm.value;\n  }\n  position(start?: number, end?: number) {\n    const { selectionStart, selectionEnd } = this.elm;\n    this.start = typeof start === 'number' && !isNaN(start) ? start : selectionStart;\n    this.end = typeof end === 'number' && !isNaN(end) ? end : selectionEnd;\n    this.elm.selectionStart = this.start;\n    this.elm.selectionEnd = this.end;\n    return this;\n  }\n  insertText(text: string) {\n    // Most of the used APIs only work with the field selected\n    this.elm.focus();\n    this.elm.setRangeText(text);\n    this.value = this.elm.value;\n    this.position();\n    return this;\n  }\n  getSelectedValue(start?: number, end?: number) {\n    const { selectionStart, selectionEnd } = this.elm;\n    return this.value.slice(\n      typeof start === 'number' && !isNaN(start) ? start : selectionStart,\n      typeof end === 'number' && !isNaN(end) ? start : selectionEnd,\n    );\n  }\n  getLineStartNumber() {\n    let start = this.start;\n    while (start > 0) {\n      start--;\n      if (this.value.charAt(start) === '\\n') {\n        start++;\n        break;\n      }\n    }\n    return start;\n  }\n  /** Indent on new lines */\n  getIndentText() {\n    const start = this.getLineStartNumber();\n    const str = this.getSelectedValue(start);\n    let indent = '';\n    str.replace(/(^(\\s)+)/, (str, old) => (indent = old));\n    return indent;\n  }\n  lineStarInstert(text: string) {\n    if (text) {\n      const oldStart = this.start;\n      const start = this.getLineStartNumber();\n      const str = this.getSelectedValue(start);\n      this.position(start, this.end)\n        .insertText(\n          str\n            .split('\\n')\n            .map((txt) => text + txt)\n            .join('\\n'),\n        )\n        .position(oldStart + text.length, this.end);\n    }\n    return this;\n  }\n  lineStarRemove(text: string) {\n    if (text) {\n      const oldStart = this.start;\n      const start = this.getLineStartNumber();\n      const str = this.getSelectedValue(start);\n      const reg = new RegExp(`^${text}`, 'g');\n      let newStart = oldStart - text.length;\n      if (!reg.test(str)) {\n        newStart = oldStart;\n      }\n      this.position(start, this.end)\n        .insertText(\n          str\n            .split('\\n')\n            .map((txt) => txt.replace(reg, ''))\n            .join('\\n'),\n        )\n        .position(newStart, this.end);\n    }\n  }\n  /** Notify any possible listeners of the change */\n  notifyChange() {\n    const event = new Event('input', { bubbles: true, cancelable: false });\n    this.elm.dispatchEvent(event);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}